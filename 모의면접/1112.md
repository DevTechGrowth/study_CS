|면접자|면접관|
|--|--|
|예은(게임클라이언트)|다영, 홍근|

**Q. 광케이블 - 속도가 빠름, 단점은?**
- 비친환경..ㅎ..
- 신호를 빛으로 변환하는 장치가 필요
- 섬유 : 깨지가 쉽다!

**Q. 헬스체크, 네트워크 오류 발생시 대처법?**
- 서킷 브레이커 : 오류난 서버를 끊어버리고 다른쪽으로 돌림
- https://velog.io/@usaindream/%ED%83%9C%EC%8A%A4%ED%81%AC-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%99%80-%EC%84%9C%EB%B9%84%EC%8A%A4

**Q. 인터넷 계층 처리하는 기기**
- 라우터, L3스위치(=L2스위치 + 라우팅)

**Q. TCP(4) / UDP(??)**
=> 보강 필요
UDP : 속도가 빠르다 (신뢰성 < 연속성) : 실시간 스트리밍


----

|면접자|면접관|
|--|--|
|홍근(서버)|다영, 예은|

**Q.  공통적인 기능을 원본 코드를 수정 없이 확장 가능한 패턴**
- 프록시 패턴
- 가상 프록시, 원격 프록시 => x
- 기본 프록시 : 추상화하는데 많이 사용

=> 어댑터 패턴
- 호환되지 않는 클래스(어댑티)를 인터페이스(Target)로 묶음 => 호환시켜줌(어댑터)
 
-공통점 : 원본코드 수정X => 확장
-차이점 : 
	- 어댑터 : 호환 안되는 걸 호환시킴
	- 프록시 : 공통을 확장


**Q. 객체 지향 프로그래밍의 장단점**
- 객체간의 조립
- vs 절차 지향 
	- 코드가 난잡
- 장덤 : 사람친숙형(자연적인 모델링)
	- 이해하기 쉽다
- 단점 : 추상화가 어려움, 설계 난이도가 높다

**Q. 어댑터 vs 데코레이터**
- 데코레이터 장점 : 내부적으로 복잡한 걸 처리할 때, 클래스는 늘어나도 코드의 유지보수가 높음
코드의 직접적 변경X, 새 클래스 작성
OOP의 원칙을 잘 지킴

**Q. OOP의 SOLID 원칙**
- 단일 책임 원칙 : Single responsibility Principal, 코드 수정의 이유는 한가지. 클래스는 자신의 책임을 명확히 해야한다
- OCP 원칙 : open-closed principal, 확장-열림, 변경-닫힘
- 리스코프 원칙 : Liskov Substitution Principal, 상위 타입으로 하위 타입의 인스턴스를 제어 가능


----

|면접자|면접관|
|--|--|
|다영(데이터)|홍근, 예은|


**Q. 관계형 데이터베이스의 N:M 관계에 대해서 설명해 주세요.**
- 한쪽에서 다른쪽의 entity를 갖는 관계
- ex) 학원:학생(1:N), 학생:학원(1:N)
- 관계형DB에서 양쪽 entity 모두가 서로에게 1:N 관계를 갖는 구조입니다.

**Q. 트랜잭션**
- DB에서 여러 쿼리를 넣을 때, 이 쿼리들을 하나로 묶는 단위
- 쿼리? : DB에 요청하는 명령어
- DB내에서 수행되는 작업의 최소 단위. DB의 무결성을 유지하며, DB의 상태를 변화시키는 기능을 수행. 4가지 규칙

**Q. 트랜잭션의 4가지 규칙**
- ACID
- 원자성, 일관성, 고립성(격리성), 지속성

**Q. 관계형(SQL) vs 비관계형(NoSQL)**
- https://aws.amazon.com/ko/compare/the-difference-between-relational-and-non-relational-databases/
- 관계형 : 2가지 특징(데이터가 스키마에 따라 정해짐, 관계에 따라 분산됨). 스키마를 준수하지 않은 데이터는 레코드에 추가 못함. 일관성 보장
- 비관계형 : 스키마X, 관계X. JSON와 비슷한 형태. 구조가 달라도 같은 콜렉션에 추가 가능. JOIN이 없음(=> 콜렉션 데이터를 복제). 자주 변경하지 않는 데이터를 쓸 때 적절. 일관성X

**Q. 정규화 순차적 진행 - 정규화하는 이유와 장단점**
=> 보강 필요
- 안정성, 무결성 유지
- 원자성 해결을 위해





