# Chapter 4 데이터베이스

## 4.5 인덱스

### 4.5.4 인덱스 최적화 기법

#### 1. 인덱스는 비용이다
- 인덱스는 두 번 탐색하도록 강요. 인덱스 리스트->컬렉션 순으로 탐색하기 때문
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 함. 이때 B-트리의 높이를 균형 있게 조절하는 비용, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용 발생
- 따라서 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아님
- 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용은 비효율적

#### 2. 항상 테스팅하라
- `explain()` 함수로 인덱스를 만들고 쿼리를 보낸 이후에 테스팅하며 걸리는 시간을 최소화해야 함
- MySQL에서의 테스팅 코드
- ```sql
  EXPLAIN
  SELECT *
  FROM t1
  JOIN t2 ON t1.c1 = t2.c1;
  ```

#### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
보통 여러 필드를 기반으로 조회 시 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.

같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.

다음은 인덱스 설정 시 우선순위이다.

1. `==`이나 `equal`이라는 쿼리
2. 정렬에 쓰는 필드
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 `>`이거나 `<` 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드
4. 카디널리티(=유니크한 값의 정도)가 높은 순서대로 (e.g. email > age)


#### 쿼리 성능을 향상시키기 위한 방법
EXPLAIN SELECT 결과를 바탕으로 쿼리 성능을 향상시키기 위해 다음과 같은 방법을 고려할 수 있다.
1. 인덱스를 추가하거나 변경하기
EXPLAIN SELECT에서 type 값이 "ALL"인 경우, 전체 테이블 스캔을 수행하고 있습니다. 이 경우 인덱스를 추가하거나 변경하여 인덱스 스캔을 통해 데이터를 더 빠르게 가져올 수 있습니다.

    예를 들어, 위 예제에서는 age 컬럼에 대한 인덱스가 이미 생성되어 있습니다. 하지만, 다른 필드를 사용하는 쿼리에서는 인덱스를 추가해야 할 수도 있습니다.

2. WHERE 절을 최적화하기
WHERE 절에서 사용되는 조건을 최적화하여 반환되는 row의 수를 줄일 수 있습니다. 이를 통해 쿼리 실행 시간을 단축할 수 있습니다.

    예를 들어, 위 예제에서는 age > 30 조건을 사용하고 있습니다. 이 조건은 인덱스를 사용하여 row를 찾고 있기 때문에, WHERE 절에서 사용되는 조건을 최적화하여 인덱스를 효과적으로 활용할 수 있도록 할 수 있습니다.

3. ORDER BY 절을 최적화하기
ORDER BY 절에서는 인덱스를 최대한 활용하도록 인덱스 스캔 방향을 변경할 수 있습니다. 이를 통해 쿼리 실행 시간을 단축할 수 있습니다.

    예를 들어, 위 예제에서는 id DESC를 사용하고 있습니다. 이 경우, 인덱스의 역방향 스캔을 사용하여 데이터를 가져올 수 있습니다.

4. LIMIT 절을 추가하기
반환되는 row의 수를 제한하는 LIMIT 절을 추가하여 쿼리 실행 시간을 단축할 수 있습니다.

    위 예제에서는 LIMIT 10으로 설정되어 있기 때문에, 최대 10개의 row만 반환됩니다. LIMIT 절을 사용하지 않은 경우, 전체 row를 가져와야 하기 때문에 쿼리 실행 시간이 더 오래 걸릴 수 있습니다.
  
